import pprint
import hashlib

from django.conf import settings
from django.contrib import messages
from django.shortcuts import redirect, render
from django.utils.translation import ugettext as _


from oscar.apps.checkout.views import ShippingMethodView as OscarShippingMethodView, \
                                        PaymentDetailsView as OscarPaymentDetailsView
from oscar.apps.payment.exceptions import PaymentError
from oscar.apps.payment import models
from oscar.apps.checkout.views import PaymentMethodView as OscarPaymentMethodView

pp = pprint.PrettyPrinter(indent=4)


class ShippingMethodView(OscarShippingMethodView):

    def get_success_response(self):
        '''
        Overriding the default behaviour in order
        to skip the `select payment-method` view
        and go directly to the pre
        '''
        return redirect('checkout:preview')


class PaymentMethodView(OscarPaymentMethodView):
    """
    View for a user to choose which payment method(s) they want to use.

    This would include setting allocations if payment is to be split
    between multiple sources. It's not the place for entering sensitive details
    like bankcard numbers though - that belongs on the payment details view.
    """
    pre_conditions = [
        'check_basket_is_not_empty',
        'check_basket_is_valid',
        'check_user_email_is_captured',
        'check_shipping_data_is_captured']
    skip_conditions = ['skip_unless_payment_is_required']

    def get(self, request, *args, **kwargs):
        # By default we redirect straight onto the payment details view. Shops
        # that require a choice of payment method may want to override this
        # method to implement their specific logic.
        return self.get_success_response()

    def get_success_response(self):
        return redirect('checkout:payment-details')


class PaymentDetailsView(OscarPaymentDetailsView):

    def get_context_data(self, **kwargs):
        context = super(PaymentDetailsView, self).get_context_data(**kwargs)
        context['submit'] = self.collect_submit_data()
        return context

    @staticmethod
    def collect_submit_data():
        submit = {
            'url' : settings.CHECKOUT_SUBMIT_URL,
            'account_number' : settings.CHECKOUT_ACCOUNT_NUMBER,
        }
        return submit


class ReturnCheckoutView(PaymentDetailsView):

    def get(self, request, *args, **kwargs):
        action_param = request.GET.get('action', None)
        if action_param is not None:
            try:
                self.handle_place_order_submission(action=action_param, params=request.GET)
            except PaymentError:
                messages.error(self.request, _('''Something went wrong during your card processing.
                        #                                         Please Try again, if the problem persist please,
                        #                                          contact our server administrator.'''))
        return redirect('checkout:preview')

        #
        #     pass
        # else:
        #

    def handle_place_order_submission(self, **kwargs):
        """
        Handle a request to place an order.
        This method is normally called after the customer has clicked "place
        order" on the preview page. It's responsible for (re-)validating any
        form information then building the submission dict to pass to the
        `submit` method.
        If forms are submitted on your payment details view, you should
        override this method to ensure they are valid before extracting their
        data into the submission dict and passing it onto `submit`.
        """
        action, resp = kwargs.get('action'), kwargs.get('params')

        if action == 'place_order':
            if not self.is_valid_payment_response(resp=resp):
                # The card payment wasn't successfull
                raise PaymentError('The payment wasn\'t successfull')


        return self.submit(**self.build_submission())





    @staticmethod
    def is_valid_payment_response(resp):
        # Changes made here -> didn't test yet, but should be working
        order_number = resp['order_number']
        total = resp['total']
        key = resp['key']
        new_key = hashlib.md5()
        new_key.update(settings.CHECKOUT_SECRET_KEY.encode('utf8'))
        new_key.update(settings.CHECKOUT_ACCOUNT_NUMBER.encode('utf8'))
        new_key.update(order_number.encode('utf8'))
        new_key.update(total.encode('utf8'))
        check_hash = new_key.hexdigest()
        check_hash = check_hash.upper()
        return key == check_hash

    def handle_payment(self, order_number, order_total, **payment_kwargs):
        '''
        At this point the payment should be successfull
        and we just handle the payment on the
        oscar level.
        :param order_number: This is the Order number from, generated by oscar
        :param order_total: total amount paid by the user
        '''
        source_type, is_created = models.SourceType.objects.get_or_create(
            name='2Checkout')
        source = source_type.sources.model(
            source_type=source_type,
            amount_allocated=order_total.incl_tax, currency=order_total.currency)
        self.add_payment_source(source)
        self.add_payment_event('Authorised', order_total.incl_tax)
